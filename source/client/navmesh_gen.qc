#define NAVGEN_PHASE_RASTERIZATION					1
#define NAVGEN_PHASE_RECTANGLE_EXPANSION			2
#define NAVGEN_PHASE_RECTANGLE_VECTORIZATION		3
#define NAVGEN_PHASE_RECTANGLE_TRIANGULATION		4
#define NAVGEN_PHASE_MESH_DETRIANGULATION			5
#define NAVGEN_PHASE_DONE							6
int navgen_phase;

// ---------------------------------------------------------------------------
// NAVGEN_PHASE_RASTERIZATION
// ---------------------------------------------------------------------------
void cl_navgen_phase_rasterization_start();
void cl_navgen_phase_rasterization_step();
int cl_navgen_phase_rasterization_finished();
void cl_navgen_draw_phase_rasterization();
// Cells
struct navgen_cell;
navgen_cell *(int x, int y, int z) create_cell;
void(navgen_cell *cell) delete_cell;
void(navgen_cell *cell, navgen_cell **list_root) add_cell_to_list;
void(navgen_cell *cell, navgen_cell **list_root) remove_cell_from_list;
navgen_cell *(navgen_cell *cell, navgen_cell **list_root) cell_in_list;
navgen_cell *(navgen_cell *cell, navgen_cell **list_root) matching_cell_in_list;
navgen_cell *(int x, int y, int z, navgen_cell **list_root) get_cell_from_list;
// Boundaries
struct navgen_boundary;
navgen_boundary *(int x, int y, int z, int ofs_x, int ofs_y) create_boundary;
void(navgen_boundary *boundary) delete_boundary;
void(navgen_boundary *boundary, navgen_boundary **list_root) add_boundary_to_list;
void(navgen_boundary *boundary, navgen_boundary **list_root) remove_boundary_from_list;
navgen_boundary *(int x, int y, int z, int ofs_x, int ofs_y, navgen_boundary **list_root) get_boundary_from_list;
// Data
navgen_cell *open_list_root_node;
navgen_cell *closed_list_root_node;
navgen_boundary *boundary_list_root_node;
int navgen_cell_size = 8;
// ---------------------------------------------------------------------------
// NAVGEN_PHASE_RECTANGLE_EXPANSION
// ---------------------------------------------------------------------------
void cl_navgen_phase_rectangle_expansion_start();
void cl_navgen_phase_rectangle_expansion_step();
int cl_navgen_phase_rectangle_expansion_finished();
void cl_navgen_draw_phase_rectangle_expansion();
// Rectangles
struct navgen_rectangle;
navgen_rectangle *() create_rect;
void(navgen_rectangle *rect) delete_rect;
void(navgen_rectangle *rect, navgen_rectangle **list_root) add_rect_to_list;
void(navgen_rectangle *rect, navgen_rectangle **list_root) remove_rect_from_list;
// Zones
struct navgen_zone;
navgen_zone *(navgen_cell *tr_cell, navgen_cell *br_cell, navgen_cell *bl_cell, navgen_cell *tl_cell) create_zone;
void(navgen_zone *zone) delete_zone;
void(navgen_zone *zone, navgen_zone **list_root) add_zone_to_list;
void(navgen_zone *zone, navgen_zone **list_root) remove_zone_from_list;
int(navgen_zone *zone, navgen_zone **list_root) is_zone_in_list;
int(navgen_zone **cur, navgen_rectangle *rect) top_edge_iter;
int(navgen_zone **cur, navgen_rectangle *rect) right_edge_iter; 
int(navgen_zone **cur, navgen_rectangle *rect) bottom_edge_iter;
int(navgen_zone **cur, navgen_rectangle *rect) left_edge_iter;
// Data
navgen_rectangle *navgen_rectangles;
navgen_zone *zones_to_process;
navgen_zone *zones_processed;
// ---------------------------------------------------------------------------
// NAVGEN_PHASE_RECTANGLE_VECTORIZATION
// ---------------------------------------------------------------------------
void cl_navgen_phase_rectangle_vectorization_start();
void cl_navgen_phase_rectangle_vectorization_step();
int cl_navgen_phase_rectangle_vectorization_finished();
void cl_navgen_draw_phase_rectangle_vectorization();
// ---------------------------------------------------------------------------
// NAVGEN_PHASE_RECTANGLE_TRIANGULATION
// ---------------------------------------------------------------------------
void cl_navgen_phase_rectangle_triangulation_start();
void cl_navgen_phase_rectangle_triangulation_step();
int cl_navgen_phase_rectangle_triangulation_finished();
void cl_navgen_draw_phase_rectangle_triangulation();
// Circular doubley-linked list for alorithm
struct cdll_node;
cdll_node *(void *data) create_cdll_node;
void(cdll_node *node) delete_cdll_node;
void(cdll_node *node, cdll_node **list_root) add_cdll_node_to_list;
void(cdll_node *node, cdll_node **list_root) remove_cdll_node_from_list;
// ---------------------------------------------------------------------------
// NAVGEN_PHASE_MESH_DETRIANGULATION
// ---------------------------------------------------------------------------
void cl_navgen_phase_mesh_detriangulation_start();
void cl_navgen_phase_mesh_detriangulation_step();
int cl_navgen_phase_mesh_detriangulation_finished();
void cl_navgen_draw_phase_mesh_detriangulation();
// ---------------------------------------------------------------------------
// NAVGEN_PHASE_DONE
// ---------------------------------------------------------------------------
navgen_cell *navgen_cells_to_add_verts_to;
navgen_cell *navgen_cells_to_add_quads_to;


void() navgen_start =
{
	navgen_phase = NAVGEN_PHASE_RASTERIZATION;
	cl_navgen_phase_rasterization_start();
}


void() navgen_logic =
{
	if(navgen_phase == NAVGEN_PHASE_RASTERIZATION)
	{
		cl_navgen_phase_rasterization_step();

		if(cl_navgen_phase_rasterization_finished())
		{
			navgen_phase = NAVGEN_PHASE_RECTANGLE_EXPANSION;
			cl_navgen_phase_rectangle_expansion_start();
		}
	}
	else if(navgen_phase == NAVGEN_PHASE_RECTANGLE_EXPANSION)
	{
		cl_navgen_phase_rectangle_expansion_step();

		if(cl_navgen_phase_rectangle_expansion_finished())
		{
			navgen_phase = NAVGEN_PHASE_RECTANGLE_VECTORIZATION;
			cl_navgen_phase_rectangle_vectorization_start();
		}
	}
	else if(navgen_phase == NAVGEN_PHASE_RECTANGLE_VECTORIZATION)
	{
		cl_navgen_phase_rectangle_vectorization_step();

		if(cl_navgen_phase_rectangle_vectorization_finished())
		{
			navgen_phase = NAVGEN_PHASE_RECTANGLE_TRIANGULATION;
			cl_navgen_phase_rectangle_triangulation_start();
		}
	}
	else if(navgen_phase == NAVGEN_PHASE_RECTANGLE_TRIANGULATION)
	{
		cl_navgen_phase_rectangle_triangulation_step();

		if(cl_navgen_phase_rectangle_triangulation_finished())
		{
			navgen_phase = NAVGEN_PHASE_MESH_DETRIANGULATION;
			cl_navgen_phase_mesh_detriangulation_start();
		}
	}
	else if(navgen_phase == NAVGEN_PHASE_MESH_DETRIANGULATION)
	{
		cl_navgen_phase_mesh_detriangulation_step();

		if(cl_navgen_phase_mesh_detriangulation_finished())
		{
			navgen_phase = NAVGEN_PHASE_DONE;
		}
	}


	if(navgen_phase == NAVGEN_PHASE_RASTERIZATION)
	{
		cl_navgen_draw_phase_rasterization();
	}
	else if(navgen_phase == NAVGEN_PHASE_RECTANGLE_EXPANSION)
	{
		cl_navgen_draw_phase_rasterization();
		cl_navgen_draw_phase_rectangle_expansion();
	}
	else if(navgen_phase == NAVGEN_PHASE_RECTANGLE_VECTORIZATION)
	{
		cl_navgen_draw_phase_rectangle_expansion();
		cl_navgen_draw_phase_rectangle_vectorization();
	}
	else if(navgen_phase == NAVGEN_PHASE_RECTANGLE_TRIANGULATION)
	{
		cl_navgen_draw_phase_rectangle_vectorization();
		cl_navgen_draw_phase_rectangle_triangulation();
	}
	else if(navgen_phase == NAVGEN_PHASE_MESH_DETRIANGULATION)
	{
		cl_navgen_draw_phase_rectangle_vectorization();
		cl_navgen_draw_phase_rectangle_triangulation();
	}
	else if(navgen_phase == NAVGEN_PHASE_DONE)
	{
		cl_navgen_draw_phase_rectangle_vectorization();
		cl_navgen_draw_phase_rectangle_triangulation();
	}

	// All draw methods
	// cl_navgen_draw_phase_rasterization();
	// cl_navgen_draw_phase_rectangle_expansion();
	// cl_navgen_draw_phase_rectangle_vectorization();
	// cl_navgen_draw_phase_rectangle_triangulation();
	// cl_navgen_draw_phase_mesh_detriangulation();
}




// ===========================================================================================================
// NAVGEN_PHASE_RASTERIZATION
// ===========================================================================================================

// TODO - Should implement K-D trees to speed up map rasterization
// Need to implement the following K-D tree functions:
//		insertion
//		deletion
//		search

// ------------------------------------------------------------------------------------------------------
// navgen_cell struct and linked list logic
// ------------------------------------------------------------------------------------------------------
struct navgen_cell
{
	int x;
	int y;
	int z;

	// Neighbor cells
	navgen_cell *y_next;
	navgen_cell *x_next;
	navgen_cell *y_prev;
	navgen_cell *x_prev;

	// Linked list node
	navgen_cell *next;

	// Cached pointer to the list containing this cell
	navgen_cell **containing_list;

	// Pointer to which zone was created for this cell, if any
	navgen_zone *zone;
};

navgen_cell *(int x, int y, int z) create_cell = 
{
	navgen_cell *new_cell = memalloc(sizeof(navgen_cell));
	new_cell->x = x;
	new_cell->y = y;
	new_cell->z = z;
	new_cell->y_next = 0;
	new_cell->x_next = 0;
	new_cell->y_prev = 0;
	new_cell->x_prev = 0;
	new_cell->containing_list = 0;
	new_cell->zone = 0;
	new_cell->next = 0;
	return new_cell;
}

void(navgen_cell *cell) delete_cell = 
{
	memfree(cell);
}

void(navgen_cell *cell, navgen_cell **list_root) add_cell_to_list = 
{
	if(*list_root != 0)
	{
		cell->next = *list_root;
	}
	*list_root = cell;
	cell->containing_list = list_root;
}

void(navgen_cell *cell, navgen_cell **list_root) remove_cell_from_list =
{
	if(cell->containing_list != list_root)
		return;
	
	if(cell == *list_root)
	{
		*list_root = (*list_root)->next;
		cell->next = 0;
		cell->containing_list = 0;
		return;
	}

	navgen_cell *prev_cell = *list_root;
	navgen_cell *cur_cell = (*list_root)->next;

	while(cur_cell != 0)
	{
		if(cur_cell == cell)
		{
			prev_cell->next = cur_cell->next;
			cur_cell->next = 0;
			cell->containing_list = 0;
			return;
		}

		prev_cell = cur_cell;
		cur_cell = cur_cell->next;
	}
}

// Checks if 'cell' is in the linked list starting at 'list_root'
// If it is, returns a pointer to cell,
// Otherwise, returns 0
navgen_cell *(navgen_cell *cell, navgen_cell **list_root) cell_in_list =
{
	if(cell->containing_list == list_root)
	{
			return cell;
	}
	return 0;
}

// Checks if a cell with the same values as 'cell' is in the linked list starting at 'list_root'
// If it is, returns a pointer to the first matching cell,
// Otherwise, returns 0
navgen_cell *(navgen_cell *cell, navgen_cell **list_root) matching_cell_in_list =
{
	navgen_cell *cur_cell = *list_root;

	while(cur_cell != 0)
	{
		if(cur_cell->x == cell->x && cur_cell->y == cell->y && cur_cell->z == cell->z)
		{
			return cur_cell;
		}
		cur_cell = cur_cell->next;
	}

	return 0;
}


navgen_cell *(int x, int y, int z, navgen_cell **list_root) get_cell_from_list =
{
	navgen_cell *cur_cell = *list_root;

	int iters = 0;

	while(cur_cell != 0)
	{
		// HACK HACK HACK HACK HACK HACK 
		// Easy hack to bypass 10k runaway loop error
		// HACK HACK HACK HACK HACK HACK 
		if(iters > 9000)
		{
			return get_cell_from_list(x,y,z,&cur_cell);
		}
		iters++;
		// HACK HACK HACK HACK HACK HACK 
		if(cur_cell->x == x && cur_cell->y == y && cur_cell->z == z)
		{
			return cur_cell;
		}
		cur_cell = cur_cell->next;
	}
	return 0;
}

void mark_cells_as_neighbors(navgen_cell *a, navgen_cell *b, int ofs_x, int ofs_y) = 
{
	// Assume that (ofs_x,ofs_y) takes us from a to b
	if(ofs_x == 0 && ofs_y == 1)
	{
		a->y_next = b;
		b->y_prev = a;
	}
	else if(ofs_x == 1 && ofs_y == 0)
	{
		a->x_next = b;
		b->x_prev = a;
	}
	else if(ofs_x == 0 && ofs_y == -1)
	{
		a->y_prev = b;
		b->y_next = a;
	}
	else if(ofs_x == -1 && ofs_y == 0)
	{
		a->x_prev = b;
		b->x_next = a;
	}
}

vector get_cell_pos(navgen_cell *cell) = 
{
	return [cell->x, cell->y, cell->z];
}
// ------------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------------
// navgen_boundary struct and linked list logic
// ------------------------------------------------------------------------------------------------------

struct navgen_boundary
{
	int x;
	int y;
	int z;
	int ofs_x;
	int ofs_y;

	// Linked list node
	navgen_boundary *next;
};

navgen_boundary *(int x, int y, int z, int ofs_x, int ofs_y) create_boundary = 
{
	navgen_boundary *new_boundary = memalloc(sizeof(navgen_boundary));
	new_boundary->x = x;
	new_boundary->y = y;
	new_boundary->z = z;
	new_boundary->ofs_x = ofs_x;
	new_boundary->ofs_y = ofs_y;
	new_boundary->next = 0;
	return new_boundary;
}

void(navgen_boundary *boundary) delete_boundary = 
{
	memfree(boundary);
}

void(navgen_boundary *boundary, navgen_boundary **list_root) add_boundary_to_list = 
{
	if(*list_root != 0)
	{
		boundary->next = *list_root;
	}
	*list_root = boundary;
}

void(navgen_boundary *boundary, navgen_boundary **list_root) remove_boundary_from_list =
{
	if(boundary == *list_root)
	{
		*list_root = (*list_root)->next;
		boundary->next = 0;
		return;
	}

	navgen_boundary *prev_boundary = *list_root;
	navgen_boundary *cur_boundary = (*list_root)->next;

	while(cur_boundary != 0)
	{
		if(cur_boundary == boundary)
		{
			prev_boundary->next = cur_boundary->next;
			cur_boundary->next = 0;
			return;
		}

		prev_boundary = cur_boundary;
		cur_boundary = cur_boundary->next;
	}
}

navgen_boundary *(int x, int y, int z, int ofs_x, int ofs_y, navgen_boundary **list_root) get_boundary_from_list =
{
	navgen_boundary *cur_boundary = *list_root;

	while(cur_boundary != 0)
	{
		if(cur_boundary->x == x && cur_boundary->y == y && cur_boundary->z == z && cur_boundary->ofs_x == ofs_x && cur_boundary->ofs_y == ofs_y)
		{
			return cur_boundary;
		}
		cur_boundary = cur_boundary->next;
	}
	return 0;
}
// ------------------------------------------------------------------------------------------------------

void cl_navgen_phase_rasterization_start()
{
	// If the lists have any previous nodes, delete them all
	navgen_cell *temp_cell;
	navgen_cell *temp_cell_next;

	// Empty the open list
	temp_cell = open_list_root_node;
	while(temp_cell != 0)
	{
		temp_cell_next = temp_cell->next;
		remove_cell_from_list(temp_cell, &open_list_root_node);
		delete_cell(temp_cell);
		temp_cell = temp_cell_next;
	}

	// Empty the closed list
	temp_cell = closed_list_root_node;
	while(temp_cell != 0)
	{
		temp_cell_next = temp_cell->next;
		remove_cell_from_list(temp_cell, &closed_list_root_node);
		temp_cell = temp_cell_next;
	}

	// Empty the boundary list
	navgen_boundary *temp_boundary = boundary_list_root_node;
	navgen_boundary *temp_boundary_next;
	while(temp_boundary != 0)
	{
		temp_boundary_next = temp_boundary->next;
		remove_boundary_from_list(temp_boundary, &boundary_list_root_node);
		temp_boundary = temp_boundary_next;
	}

	// Create a cell at the player's position:
	vector player_pos = getentity(player_localentnum, GE_ORIGIN);
	// Make sure it's at the floor
	navgen_drop_to_floor(player_pos);
	player_pos = trace_endpos;

	int pos_x = floor(player_pos.x);
	int pos_y = floor(player_pos.y);
	// Lift up above the floor
	int pos_z = ceil(player_pos.z);

	navgen_cell *cell = create_cell(pos_x, pos_y, pos_z);

	// Add it to the open list
	add_cell_to_list(cell, &open_list_root_node);
}
void cl_navgen_phase_rasterization_step()
{
	int verbose = 0;
	// if(verbose) print("---- Navgen logic tick start ----\n");

	navgen_cell *cur_open_list = open_list_root_node;
	navgen_cell *new_open_list = 0;

	navgen_cell *cell = cur_open_list;

	// int num_ofs = 8;
	// // One entry for each of the 8 cardinal + intercardinal directions
	// int ofs_x_vals[8] = { 0, 1, 1, 1, 0,-1,-1,-1};
	// int ofs_y_vals[8] = { 1, 1, 0,-1,-1,-1, 0, 1};
	
	int num_ofs = 4;
	int ofs_x_vals[4] = { 0, 1, 0,-1};
	int ofs_y_vals[4] = { 1, 0,-1, 0};

	while(cell != 0)
	{
		if(verbose) print("\t-- Handling cell at: (",ftos(cell->x),",",ftos(cell->y),",",ftos(cell->z),") --\n");

		// For each of the eight directions:
		for(int i = 0; i < num_ofs; i++)
		{
			int ofs_x = ofs_x_vals[i] * navgen_cell_size;
			int ofs_y = ofs_y_vals[i] * navgen_cell_size;
			int next_cell_x = cell->x + ofs_x;
			int next_cell_y = cell->y + ofs_y;
			
			if(verbose) print("\t\tCell was not in any list, continuing.\n");

			// If we can't fully walk from cell to next_cell, this is a boundary
			vector cell_pos;
			cell_pos.x = cell->x;
			cell_pos.y = cell->y;
			cell_pos.z = cell->z;

			vector next_cell_pos;
			next_cell_pos.x = next_cell_x;
			next_cell_pos.y = next_cell_y;
			next_cell_pos.z = cell->z;

			int obstructed = navgen_obstructed(cell_pos, next_cell_pos);

			// Lift up above the floor, snap to grid of size 'navgen_cell_size'
			int z_pos = cell->z + navgen_cell_size * floor((ceil(trace_endpos.z) - cell->z) / navgen_cell_size);

			// If we can't walk to it, convert it to a boundary
			if(obstructed)
			{
				if(verbose) print("\t\tCell was obstructed, logging boundary.\n");
				// Add it to our list of boundaries
				navgen_boundary *new_boundary = create_boundary(cell->x, cell->y, cell->z, ofs_x, ofs_y);
				add_boundary_to_list( new_boundary, &boundary_list_root_node);
			}
			// If we can walk to it, add it to the new open list
			else
			{
				navgen_cell *neighbor;

				// If this cell is already in the closed list, skip it
				neighbor = get_cell_from_list(next_cell_x, next_cell_y, z_pos, &closed_list_root_node);
				if(neighbor != 0)
				{
					mark_cells_as_neighbors(cell, neighbor, ofs_x_vals[i], ofs_y_vals[i]);
					if(verbose) print("\t\tCell was in closed list, skipping...\n");
					continue;
				}

				// If this cell is already in the cur open list, skip it
				neighbor = get_cell_from_list(next_cell_x, next_cell_y, z_pos, &cur_open_list);
				if(neighbor != 0)
				{
					mark_cells_as_neighbors(cell, neighbor, ofs_x_vals[i], ofs_y_vals[i]);
					if(verbose) print("\t\tCell was in cur open list, skipping...\n");
					continue;
				}

				// If this cell is already in the new open list, skip it
				neighbor = get_cell_from_list(next_cell_x, next_cell_y, z_pos, &new_open_list);
				if(neighbor != 0)
				{
					mark_cells_as_neighbors(cell, neighbor, ofs_x_vals[i], ofs_y_vals[i]);
					if(verbose) print("\t\tCell was in new open list, skipping...\n");
					continue;
				}

				if(verbose) print("\t\tCell was good, adding new cell to open list.\n");
				navgen_cell *new_cell = create_cell(next_cell_x, next_cell_y, z_pos);
				mark_cells_as_neighbors(cell, neighbor, ofs_x_vals[i], ofs_y_vals[i]);
				add_cell_to_list(new_cell, &new_open_list);
			}
		}
		
		// Get the next cell
		navgen_cell *next_cell = cell->next;

		// Remove cell from the current open list
		if(verbose) print("\t\tRemove it from the current open list\n");
		remove_cell_from_list(cell, &cur_open_list);		

		// Add cell to closed list
		if(verbose) print("\t\tAdding cell to closed list.\n");
		add_cell_to_list(cell, &closed_list_root_node);

		// Updating the loop variable
		cell = next_cell;
	}

	// Swap the open list:
	if(verbose) print("Swapping open lists.\n");
	open_list_root_node = new_open_list;

	// We have now exhausted the current open set and created a new open set
}

int cl_navgen_phase_rasterization_finished()
{
	return open_list_root_node == 0;
}

void cl_navgen_draw_phase_rasterization()
{
	vector open_cell_color = [0,0,1];
	vector closed_cell_color = [0,1,0];
	vector boundary_color = [1,0,0];

	float open_cell_alpha = 0.2;
	float closed_cell_alpha = 0.01;
	float boundary_alpha = 0.4;

	navgen_cell *cell;

	// ------------------------------------------------------------------------
	// Draw the open list
	// ------------------------------------------------------------------------
	cell = open_list_root_node;

	while(cell != 0)
	{
		cl_navmesh_draw_vert([cell->x, cell->y, cell->z],open_cell_color,open_cell_alpha);
		cell = cell->next;
	}

	// ------------------------------------------------------------------------
	// Draw the closed list
	// ------------------------------------------------------------------------
	// NOTE - The closed list of cells is MASSIVE, this kills FPS.
	// cell = closed_list_root_node;

	// while(cell != 0)
	// {
	// 	// cl_navmesh_draw_vert([cell->x, cell->y, cell->z],closed_cell_color,closed_cell_alpha);

	// 	// Draw the neighbors:
	// 	vector pos = [cell->x, cell->y, cell->z];
	// 	// Offset start pos by -8, to show direction
	// 	pos.z -= 8;
	// 	vector neighbor_pos;
	// 	navgen_cell *neighbor;

	// 	if(cell->y_next != 0)
	// 	{
	// 		neighbor = cell->y_next;
	// 		neighbor_pos = [neighbor->x, neighbor->y, neighbor->z];
	// 		cl_navmesh_draw_edge(pos, neighbor_pos);
	// 	}
	// 	if(cell->x_next != 0)
	// 	{
	// 		neighbor = cell->x_next;
	// 		neighbor_pos = [neighbor->x, neighbor->y, neighbor->z];
	// 		cl_navmesh_draw_edge(pos, neighbor_pos);
	// 	}
	// 	if(cell->y_prev != 0)
	// 	{
	// 		neighbor = cell->y_prev;
	// 		neighbor_pos = [neighbor->x, neighbor->y, neighbor->z];
	// 		cl_navmesh_draw_edge(pos, neighbor_pos);
	// 	}
	// 	if(cell->x_prev != 0)
	// 	{
	// 		neighbor = cell->x_prev;
	// 		neighbor_pos = [neighbor->x, neighbor->y, neighbor->z];
	// 		cl_navmesh_draw_edge(pos, neighbor_pos);
	// 	}
	// 	cell = cell->next;
	// }

	// ------------------------------------------------------------------------
	// Draw the boundaries
	// ------------------------------------------------------------------------

	navgen_boundary *boundary = boundary_list_root_node;

	while(boundary != 0)
	{
		cl_navmesh_draw_vert([boundary->x, boundary->y, boundary->z],boundary_color,boundary_alpha);
		boundary = boundary->next;
	}
}
// ===========================================================================================================
// NAVGEN_PHASE_RECTANGLE_EXPANSION
// ===========================================================================================================

// ------------------------------------------------------------------------------------------------------
// navgen_rectangle struct and linked list logic
// ------------------------------------------------------------------------------------------------------
struct navgen_rectangle
{
	navgen_zone *min;
	navgen_zone *max;

	// List of cells to treat as vertices
	navgen_cell *verts;

	// Linked list node
	navgen_rectangle *next;

};

navgen_rectangle *() create_rect = 
{
	navgen_rectangle *new_rect = memalloc(sizeof(navgen_rectangle));
	new_rect->min = 0;
	new_rect->max = 0;
	new_rect->next = 0;
	new_rect->verts = 0;
	new_rect->next = 0;
	return new_rect;
}

void(navgen_rectangle *rect) delete_rect = 
{
	navgen_cell *temp_cell;
	navgen_cell *temp_cell_next;

	// Delete the linked list of cell vertices
	temp_cell = rect->verts;
	while(temp_cell != 0)
	{
		temp_cell_next = temp_cell->next;
		remove_cell_from_list(temp_cell, &(rect->verts));
		delete_cell(temp_cell);
		temp_cell = temp_cell_next;
	}

	memfree(rect);
}

void(navgen_rectangle *rect, navgen_rectangle **list_root) add_rect_to_list = 
{
	if(*list_root != 0)
	{
		rect->next = *list_root;
	}
	*list_root = rect;
}

void(navgen_rectangle *rect, navgen_rectangle **list_root) remove_rect_from_list =
{
	if(rect == *list_root)
	{
		*list_root = (*list_root)->next;
		rect->next = 0;
		return;
	}

	navgen_rectangle *prev_rect = *list_root;
	navgen_rectangle *cur_rect = (*list_root)->next;

	while(cur_rect != 0)
	{
		if(cur_rect == rect)
		{
			prev_rect->next = cur_rect->next;
			cur_rect->next = 0;
			return;
		}

		prev_rect = cur_rect;
		cur_rect = cur_rect->next;
	}
}
// ------------------------------------------------------------------------------------------------------
// navgen_zone struct and linked list logic
// ------------------------------------------------------------------------------------------------------
struct navgen_zone
{
	navgen_cell *tr_cell;
	navgen_cell *br_cell;
	navgen_cell *bl_cell;
	navgen_cell *tl_cell;

	// Links to neighbors
	navgen_zone *x_next;
	navgen_zone *y_next;
	navgen_zone *x_prev;
	navgen_zone *y_prev;
	
	// Linked list node
	navgen_zone *next;

	// Cached pointer to the list containing this cell
	navgen_zone **containing_list;
};

navgen_zone *(navgen_cell *tr_cell, navgen_cell *br_cell, navgen_cell *bl_cell, navgen_cell *tl_cell) create_zone
{
	navgen_zone *new_zone = memalloc(sizeof(navgen_zone));
	new_zone->tr_cell = tr_cell;
	new_zone->br_cell = br_cell;
	new_zone->bl_cell = bl_cell;
	new_zone->tl_cell = tl_cell;
	new_zone->x_next = 0;
	new_zone->y_next = 0;
	new_zone->x_prev = 0;
	new_zone->y_prev = 0;
	new_zone->next = 0;
	new_zone->containing_list = 0;
	return new_zone;
}

void(navgen_zone *zone) delete_zone
{
	memfree(zone);
}

void(navgen_zone *zone, navgen_zone **list_root) add_zone_to_list
{
	if(*list_root != 0)
	{
		zone->next = *list_root;
	}
	*list_root = zone;
	zone->containing_list = list_root;
}

void(navgen_zone *zone, navgen_zone **list_root) remove_zone_from_list
{
	if(zone->containing_list != list_root)
		return;

	if(zone == *list_root)
	{
		*list_root = (*list_root)->next;
		zone->next = 0;
		zone->containing_list = 0;
		return;
	}

	navgen_zone *prev_zone = *list_root;
	navgen_zone *cur_zone = (*list_root)->next;

	while(cur_zone != 0)
	{
		if(cur_zone == zone)
		{
			prev_zone->next = cur_zone->next;
			cur_zone->next = 0;
			zone->containing_list = 0;
			return;
		}

		prev_zone = cur_zone;
		cur_zone = cur_zone->next;
	}
}

int(navgen_zone *zone, navgen_zone **list_root) is_zone_in_list
{
	return zone->containing_list == list_root;
	// navgen_zone *cur_zone = *list_root;
	// while(cur_zone != 0)
	// {
	// 	if(cur_zone == zone)
	// 	{
	// 		return TRUE;
	// 	}
	// 	cur_zone = cur_zone->next;
	// }
	// return FALSE;
}


// Returns the location of the zone's bottom-left cell
vector (navgen_zone *zone) get_zone_pos = 
{
	navgen_cell *cell = zone->bl_cell;
	return [cell->x, cell->y, cell->z];
}

navgen_zone *(navgen_rectangle *rect) get_top_left_zone = 
{
	navgen_zone *prev = 0;
	navgen_zone *cur = 0;
	do
	{
		prev = cur;
	}
	while(top_edge_iter(&cur, rect));
	return prev;
}

navgen_zone *(navgen_rectangle *rect) get_bottom_right_zone = 
{
	navgen_zone *prev = 0;
	navgen_zone *cur = 0;
	do
	{
		prev = cur;
	}
	while(bottom_edge_iter(&cur, rect));
	return prev;
}

int zones_are_neighbors(navgen_zone *a, navgen_zone *b) = 
{
	if(a->x_next == b && b->x_prev == a)
		return TRUE;
	if(a->x_prev == b && b->x_next == a)
		return TRUE;
	if(a->y_next == b && b->y_prev == a)
		return TRUE;
	if(a->y_prev == b && b->y_next == a)
		return TRUE;
	return FALSE;
}

// Computes the area of intersecting the rectangle with mins 'r1_min' and maxs 'r1_max', 
// with the rectangle with mins 'r2_min' and maxs 'r2_max'
float (navgen_cell *r1_min, navgen_cell *r1_max, navgen_cell *r2_min, navgen_cell *r2_max) area_of_intersection =
{
	vector r1_min_pos = [r1_min->x, r1_min->y, r1_min->z];
	vector r1_max_pos = [r1_max->x, r1_max->y, r1_max->z];
	vector r2_min_pos = [r2_min->x, r2_min->y, r2_min->z];
	vector r2_max_pos = [r2_max->x, r2_max->y, r2_max->z];

	if(r1_min_pos.x > r2_max_pos.x)
		return 0;
	if(r1_max_pos.x < r2_min_pos.x)
		return 0;
	if(r1_min_pos.y > r2_max_pos.y)
		return 0;
	if(r1_max_pos.y < r2_min_pos.y)
		return 0;

	float width  = min(r1_max_pos.x - r2_min_pos.x, r2_max_pos.x - r1_min_pos.x);
	float height = min(r1_max_pos.y - r2_min_pos.y, r2_max_pos.y - r1_min_pos.y);
	return width * height;
}

// Returns TRUE if rectangle formed by min & max intersects with any rectangles in list 'rectangles'
// If 'skip' is specified, we don't check against that rectangle.
// Returns FALSE if it does not intersect.
// int intersects_with_rectangles(navgen_cell *min, navgen_cell *max, navgen_rectangle *rect_list, navgen_rectangle *skip)
int intersects_with_rectangles(navgen_zone *min, navgen_zone *max, navgen_rectangle *rect_list, navgen_rectangle *skip)
{
	navgen_rectangle *rect;

	// // ------------------------------------------------------------------------------------
	// // Check 1 - Early out check
	// // Check if it's even possible for them to intersect (intersection on X,Y plane is > 0)
	// // ------------------------------------------------------------------------------------

	// int intersects = FALSE;


	// for(rect = rect_list; rect != 0; rect = rect->next)
	// {
	// 	if(rect == skip)
	// 		continue;		

	// 	navgen_cell *other_min = (rect->min)->bl_cell;
	// 	navgen_cell *other_max = (rect->max)->tr_cell;

	// 	if(area_of_intersection(min,max,other_min,other_max) > 0)
	// 	{
	// 		intersects = TRUE;
	// 	}
	// }

	// if(!intersects)
	// {
	// 	return FALSE;
	// }

	// ------------------------------------------------------------------------------------
	// Check 2 - Detailed check
	// Check if any of the two rectangle edges intersect
	// ------------------------------------------------------------------------------------
	navgen_rectangle temp_rect;
	// Ensure it's valid
	temp_rect.next = 0;
	temp_rect.verts = 0;
	temp_rect.min = min;
	temp_rect.max = max;

	// Iterate through all edges:
	int(navgen_zone **cur, navgen_rectangle *rect) iter_funcs[4] = {
		top_edge_iter, 
		right_edge_iter, 
		bottom_edge_iter, 
		left_edge_iter
	};


	for(rect = rect_list; rect != 0; rect = rect->next)
	{
		if(rect == skip)
			continue;

		// ------------------------------------------------------------
		// Check if any temp_rect edge intersects with any rect edge
		// ------------------------------------------------------------
		// Check all 4 sides of temp_rect
		for(int i = 0; i < 4; i++)
		{
			// Check all 4 sides of rect
			for(int j = 0; j < 4; j++)
			{
				navgen_zone *r1_zone;
				navgen_zone *r2_zone;
				
				// Check all nodes on temp_rect's edges
				for(r1_zone = 0; iter_funcs[i](&r1_zone, &temp_rect);)
				{
					// ... against all nodes on rect's edges
					for(r2_zone = 0; iter_funcs[j](&r2_zone, rect);)
					{
						// If we found one shared by both rectangles, they intersect
						if(r1_zone == r2_zone)
							return TRUE;
					}
				}
			}
		}
	}

	return FALSE;


	//  navgen_rectangle *rect;

	// for(rect = rect_list; rect != 0; rect = rect->next)
	// {
	// 	if(rect == skip)
	// 		continue;

	// 	navgen_cell *other_min = (rect->min)->bl_cell;
	// 	navgen_cell *other_max = (rect->max)->tr_cell;


	// 	navgen_cell *temp1;
	// 	navgen_cell *temp2;

	// 	// Check rect (min,max)'s top edge against rect (other_min,other_max)'s bottom edge
	// 	for(temp1 = max; temp1 != 0 && temp1->x >= min->x; temp1 = temp1->x_prev)
	// 	{
	// 		for(temp2 = other_min; temp2 != 0 && temp2->x <= other_max->x; temp2 = temp2->x_next)
	// 		{
	// 			if(temp1 == temp2)
	// 				return TRUE;
	// 		}
	// 	}
		
	// 	// Check rect (min,max)'s right edge against rect (other_min,other_max)'s left edge
	// 	for(temp1 = max; temp1 != 0 && temp1->y >= min->y; temp1 = temp1->y_prev)
	// 	{
	// 		for(temp2 = other_min; temp2 != 0 && temp2->y <= other_max->y; temp2 = temp2->y_next)
	// 		{
	// 			if(temp1 == temp2)
	// 				return TRUE;
	// 		}
	// 	}
		
	// 	// Check rect (min,max)'s bottom edge against rect (other_min,other_max)'s top edge
	// 	for(temp1 = min; temp1 != 0 && temp1->x <= max->x; temp1 = temp1->x_next)
	// 	{
	// 		for(temp2 = other_max; temp2 != 0 && temp2->x >= other_min->x; temp2 = temp2->x_prev)
	// 		{
	// 			if(temp1 == temp2)
	// 				return TRUE;
	// 		}
	// 	}

	// 	// Check rect (min,max)'s left edge against rect (other_min,other_max)'s riht edge
	// 	for(temp1 = min; temp1 != 0 && temp1->y <= max->y; temp1 = temp1->y_next)
	// 	{
	// 		for(temp2 = other_max; temp2 != 0 && temp2->y >= other_min->y; temp2 = temp2->y_prev)
	// 		{
	// 			if(temp1 == temp2)
	// 				return TRUE;
	// 		}
	// 	}
	// }
	// return FALSE;
}


// Helper function to iterate through a rectangle's top edge
// If *cur == 0, sets cur to the first zone of the rectangle's edge
// Otherwise, advances *cur to be the next zone of the rectangle's edge
// Returns FALSE if we're done iterating, TRUE otherwise
int(navgen_zone **cur, navgen_rectangle *rect) top_edge_iter = 
{
	// If we are given an empty zone, start iterating
	if(*cur == 0)
	{
		*cur = rect->max;
		return TRUE;
	}

	// If we are given the last zone of the edge, we are done
	if(get_zone_pos(*cur).x <= get_zone_pos(rect->min).x)
	{
		*cur = 0;
		return FALSE;
	}

	// Advance the zone by one
	*cur = (*cur)->x_prev;
	return TRUE;
}

// Helper function to iterate through a rectangle's right edge
// If *cur == 0, sets cur to the first zone of the rectangle's edge
// Otherwise, advances *cur to be the next zone of the rectangle's edge
// Returns FALSE if we're done iterating, TRUE otherwise
int(navgen_zone **cur, navgen_rectangle *rect) right_edge_iter = 
{
	// If we are given an empty zone, start iterating
	if(*cur == 0)
	{
		*cur = rect->max;
		return TRUE;
	}

	// If we are given the last zone of the edge, we are done
	if(get_zone_pos(*cur).y <= get_zone_pos(rect->min).y)
	{
		*cur = 0;
		return FALSE;
	}

	// Advance the zone by one
	*cur = (*cur)->y_prev;
	return TRUE;
}

// Helper function to iterate through a rectangle's bottom edge
// If *cur == 0, sets cur to the first zone of the rectangle's edge
// Otherwise, advances *cur to be the next zone of the rectangle's edge
// Returns FALSE if we're done iterating, TRUE otherwise
int(navgen_zone **cur, navgen_rectangle *rect) bottom_edge_iter = 
{
	// If we are given an empty zone, start iterating
	if(*cur == 0)
	{
		*cur = rect->min;
		return TRUE;
	}

	// If we are given the last zone of the edge, we are done
	if(get_zone_pos(*cur).x >= get_zone_pos(rect->max).x)
	{
		*cur = 0;
		return FALSE;
	}

	// Advance the zone by one
	*cur = (*cur)->x_next;
	return TRUE;
}

// Helper function to iterate through a rectangle's left edge
// If *cur == 0, sets cur to the first zone of the rectangle's edge
// Otherwise, advances *cur to be the next zone of the rectangle's edge
// Returns FALSE if we're done iterating, TRUE otherwise
int(navgen_zone **cur, navgen_rectangle *rect) left_edge_iter = 
{
	// If we are given an empty zone, start iterating
	if(*cur == 0)
	{
		*cur = rect->min;
		return TRUE;
	}

	// If we are given the last zone of the edge, we are done
	if(get_zone_pos(*cur).y >= get_zone_pos(rect->max).y)
	{
		*cur = 0;
		return FALSE;
	}

	// Advance the zone by one
	*cur = (*cur)->y_next;
	return TRUE;
}



// ------------------------------------------------------------------------------------------------------



void cl_navgen_phase_rectangle_expansion_start()
{
	// If the lists have any previous nodes, delete them all
	navgen_rectangle *temp_rect;
	navgen_rectangle *temp_rect_next;
	navgen_zone *temp_zone;
	navgen_zone *temp_zone_next;
	

	// Empty the list of zones to process
	temp_zone = zones_to_process;
	while(temp_zone != 0)
	{
		temp_zone_next = temp_zone->next;
		remove_zone_from_list(temp_zone, temp_zone->containing_list);
		delete_zone(temp_zone);
		temp_zone = temp_zone_next;
	}

	// Empty the list of zones processed
	temp_zone = zones_processed;
	while(temp_zone != 0)
	{
		temp_zone_next = temp_zone->next;
		remove_zone_from_list(temp_zone, temp_zone->containing_list);
		delete_zone(temp_zone);
		temp_zone = temp_zone_next;
	}

	// Empty the list of rectangles
	temp_rect = navgen_rectangles;
	while(temp_rect != 0)
	{
		temp_rect_next = temp_rect->next;
		remove_rect_from_list(temp_rect, &navgen_rectangles);
		delete_rect(temp_rect);
		temp_rect = temp_rect_next;
	}

	navgen_cell *temp_cell;
	navgen_cell *temp_cell_next;
	
	// For every cell in the closed list,
	// If the cell has x_next and y_next neighbors
	// and x_next's y_next == y_next's x_next
	// Create a zone there and add it to our to_process list
	for(navgen_cell *cell = closed_list_root_node; cell != 0; cell = cell->next)
	{
		// If this cell doesn't have an x_next neighbor, skip it
		if(cell->x_next == 0)
			continue;
		// If this cell doesn't have a y_next neighbor, skip it
		if(cell->y_next == 0)
			continue;
		// If this cell's x_next doesn't have a y_next neighbor, skip it
		if((cell->x_next)->y_next == 0)
			continue;
		// If this cell's y_next doesn't have a x_next neighbor, skip it
		if((cell->y_next)->x_next == 0)
			continue;
		// If this cell's neighbors don't share the same neighbor, skip it
		if((cell->x_next)->y_next != (cell->y_next)->x_next)
			continue;

		navgen_cell *bl = cell;
		navgen_cell *tl = cell->y_next;
		navgen_cell *br = cell->x_next;
		navgen_cell *tr = (cell->x_next)->y_next;

		navgen_zone *zone = create_zone(tr, br, bl, tl);
		bl->zone = zone;
		add_zone_to_list(zone, &zones_to_process);
	}

	// Link all of the zones we just created together
	for(navgen_cell *cell = closed_list_root_node; cell != 0; cell = cell->next)
	{
		if(cell->zone == 0)
			continue;

		// cell is the bottom-left corner of cell->zone

		// cell->zone's x_next neighbor's BL corner is cell->x_next
		if(cell->x_next != 0)
		{
			(cell->zone)->x_next = (cell->x_next)->zone;
		}

		// cell->zone's x_prev neighbor's BL corner is cell->x_prev
		if(cell->x_prev != 0)
		{
			(cell->zone)->x_prev = (cell->x_prev)->zone;
		}

		// cell->zone's y_next neighbor's BL corner is cell->y_next
		if(cell->y_next != 0)
		{
			(cell->zone)->y_next = (cell->y_next)->zone;
		}

		// cell->zone's y_prev neighbor's BL corner is cell->y_prev
		if(cell->y_prev != 0)
		{
			(cell->zone)->y_prev = (cell->y_prev)->zone;
		}
	}
}


void cl_navgen_phase_rectangle_expansion_step()
{
	int verbose = 0;
	verbose = 1;
	navgen_cell *cell;
	navgen_zone *zone;
	vector pos;

	// Iterate through the list of zones to process until it's empty
	// We're going to place a rectangle at each of the zones, and expand each rectangle as far as it can be
	while(zones_to_process != 0)
	{
		zone = zones_to_process;
		remove_zone_from_list(zone, &zones_to_process);
		add_zone_to_list(zone, &zones_processed);

		navgen_rectangle *rect = create_rect();
		add_rect_to_list(rect, &navgen_rectangles);

		rect->min = zone;
		rect->max = zone;

		if(verbose)
		{
			pos = get_zone_pos(zone);
			print("Created rectangle at: (",ftos(pos.x),",",ftos(pos.y),",",ftos(pos.z),")\n");
			pos = get_zone_pos(rect->min);
			print("\tRectangle bounds: (",ftos(pos.x),",",ftos(pos.y),",",ftos(pos.z),") -> ");
			pos = get_zone_pos(rect->max);
			print("(",ftos(pos.x),",",ftos(pos.y),",",ftos(pos.z),")\n");
		}

		// Keep track of which edge can no longer be expanded
		int top_can_expand = TRUE;
		int right_can_expand = TRUE;
		int bottom_can_expand = TRUE;
		int left_can_expand = TRUE;

		// Expand the rectangle in each direction as far as possible
		while(TRUE)
		{
			if(verbose)
			{
				pos = get_zone_pos(rect->min);
				print("\tRectangle bounds: (",ftos(pos.x),",",ftos(pos.y),",",ftos(pos.z),") -> ");
				pos = get_zone_pos(rect->max);
				print("(",ftos(pos.x),",",ftos(pos.y),",",ftos(pos.z),")\n");
			}

			navgen_zone *temp_zone;
			navgen_zone *last_neighbor;
			navgen_cell *temp_min;
			navgen_cell *temp_max;

			// ---------------------------------------------------
			// Increasing in +y direction
			// ---------------------------------------------------
			if(top_can_expand)
			{
				if(verbose) print("\t\t-- Checking +y --\n");
				// ----------------------------------------------------------------------
				// Check if the map geometry allows us to expand
				// ----------------------------------------------------------------------
				last_neighbor = 0;

				// Check that each top edge zone has a y_next neighbor
				for(temp_zone = 0; top_edge_iter(&temp_zone, rect);)
				{
					// If zone doesn't have a y_next neighbor
					if(temp_zone->y_next == 0)
					{
						if(verbose) print("\t\t+y failed. Reason: no neighbor.\n");
						top_can_expand = FALSE;
						break;
					}
					// If this zone's y_next is not neighbors with the last zone's y_next, then we can't expand
					if(last_neighbor != 0 && !zones_are_neighbors(temp_zone->y_next, last_neighbor))
					{
						if(verbose) print("\t\t+y failed. Reason: Two consecutive y_nexts are not neighbors.\n");
						top_can_expand = FALSE;
						break;
					}
					// If this zone's y_next has already been processed, then we can't expand to it
					if(is_zone_in_list(temp_zone->y_next, &zones_processed))
					{
						if(verbose) print("\t\t+y failed. Reason: Neighbor zone has already been processed.\n");
						top_can_expand = FALSE;
						break;
					}
					last_neighbor = temp_zone->y_next;					
				}
				// ----------------------------------------------------------------------
				// Check if we are expanding into another rectangle
				// ----------------------------------------------------------------------
				// if(top_can_expand)
				// {
				// 	if(intersects_with_rectangles(rect->min, (rect->max)->y_next, navgen_rectangles, rect))
				// 	{
				// 		top_can_expand = FALSE;
				// 	}
				// }
				// ----------------------------------------------------------------------
				// If we got to the edge and found them all, expand the rectangle
				// ----------------------------------------------------------------------
				if(top_can_expand)
				{
					// Sweep again, adding all the zones to the rect
					for(temp_zone = 0; top_edge_iter(&temp_zone, rect);)
					{
						remove_zone_from_list(temp_zone->y_next, &zones_to_process);
						add_zone_to_list(temp_zone->y_next, &zones_processed);
					}
					// Update top-right zone
					rect->max = (rect->max)->y_next;
					if(verbose) print("\t\tExpanded rectangle at +y\n");
				}
			}
			// ---------------------------------------------------

			// ---------------------------------------------------
			// Increasing in +x direction
			// ---------------------------------------------------
			if(right_can_expand)
			{
				if(verbose) print("\t\t-- Checking +x --\n");
				// ----------------------------------------------------------------------
				// Check if the map geometry allows us to expand
				// ----------------------------------------------------------------------
				last_neighbor = 0;

				// Check that each right edge zone hsa a x_next neighbor
				for(temp_zone = 0; right_edge_iter(&temp_zone, rect);)
				{
					// If zone doesn't have a x_next neighbor
					if(temp_zone->x_next == 0)
					{
						if(verbose) print("\t\t+x failed. Reason: no neighbor.\n");
						right_can_expand = FALSE;
						break;
					}
					// If this zone's x_next is not neighbors with the last zone's x_next, then we can't expand
					if(last_neighbor != 0 && !zones_are_neighbors(temp_zone->x_next, last_neighbor))
					{
						if(verbose) print("\t\t+x failed. Reason: Two consecutive x_nexts are not neighbors.\n");
						right_can_expand = FALSE;
						break;
					}
					// If this zone's x_next has already been processed, then we can't expand to it
					if(is_zone_in_list(temp_zone->x_next, &zones_processed))
					{
						if(verbose) print("\t\t+x failed. Reason: Neighbor zone has already been processed.\n");
						right_can_expand = FALSE;
						break;
					}
					last_neighbor = temp_zone->x_next;					
				}
				// ----------------------------------------------------------------------
				// Check if we are expanding into another rectangle
				// ----------------------------------------------------------------------
				// if(right_can_expand)
				// {
				// 	if(intersects_with_rectangles(rect->min, (rect->max)->x_next, navgen_rectangles, rect))
				// 	{
				// 		right_can_expand = FALSE;
				// 	}
				// }
				// ----------------------------------------------------------------------
				// If we got to the edge and found them all, expand the rectangle
				// ----------------------------------------------------------------------
				if(right_can_expand)
				{
					// Sweep again, adding all the zones to the rect
					for(temp_zone = 0; right_edge_iter(&temp_zone, rect);)
					{
						remove_zone_from_list(temp_zone->x_next, &zones_to_process);
						add_zone_to_list(temp_zone->x_next, &zones_processed);
					}
					// Update top-right zone
					rect->max = (rect->max)->x_next;
					if(verbose) print("\t\tExpanded rectangle at +x\n");
				}
			}
			// ---------------------------------------------------

			// ---------------------------------------------------
			// Increasing in -y direction
			// ---------------------------------------------------
			if(bottom_can_expand)
			{
				if(verbose) print("\t\t-- Checking -y --\n");
				// ----------------------------------------------------------------------
				// Check if the map geometry allows us to expand
				// ----------------------------------------------------------------------
				last_neighbor = 0;

				// Check that each bottom edge zone hsa a y_prev neighbor
				for(temp_zone = 0; bottom_edge_iter(&temp_zone, rect);)
				{
					// If zone doesn't have a y_prev neighbor
					if(temp_zone->y_prev == 0)
					{
						if(verbose) print("\t\t-y failed. Reason: no neighbor.\n");
						bottom_can_expand = FALSE;
						break;
					}
					// If this zone's y_prev is not neighbors with the last zone's y_prev, then we can't expand
					if(last_neighbor != 0 && !zones_are_neighbors(temp_zone->y_prev, last_neighbor))
					{
						if(verbose) print("\t\t-y failed. Reason: Two consecutive y_prevs are not neighbors.\n");
						bottom_can_expand = FALSE;
						break;
					}
					// If this zone's y_prev has already been processed, then we can't expand to it
					if(is_zone_in_list(temp_zone->y_prev, &zones_processed))
					{
						if(verbose) print("\t\t-y failed. Reason: Neighbor zone has already been processed.\n");
						bottom_can_expand = FALSE;
						break;
					}
					last_neighbor = temp_zone->y_prev;					
				}
				// ----------------------------------------------------------------------
				// Check if we are expanding into another rectangle
				// ----------------------------------------------------------------------
				// if(bottom_can_expand)
				// {
				// 	if(intersects_with_rectangles((rect->min)->y_prev, rect->max, navgen_rectangles, rect))
				// 	{
				// 		bottom_can_expand = FALSE;
				// 	}
				// }
				// ----------------------------------------------------------------------
				// If we got to the edge and found them all, expand the rectangle
				// ----------------------------------------------------------------------
				if(bottom_can_expand)
				{
					// Sweep again, adding all the zones to the rect
					for(temp_zone = 0; bottom_edge_iter(&temp_zone, rect);)
					{
						remove_zone_from_list(temp_zone->y_prev, &zones_to_process);
						add_zone_to_list(temp_zone->y_prev, &zones_processed);
					}
					// Update bottom-left zone
					rect->min = (rect->min)->y_prev;
					if(verbose) print("\t\tExpanded rectangle at -y\n");
				}
			}
			// ---------------------------------------------------

			// ---------------------------------------------------
			// Increasing in -x direction
			// ---------------------------------------------------
			if(left_can_expand)
			{
				if(verbose) print("\t\t-- Checking -x --\n");
				// ----------------------------------------------------------------------
				// Check if the map geometry allows us to expand
				// ----------------------------------------------------------------------
				last_neighbor = 0;

				// Check that each left edge zone hsa a x_prev neighbor
				for(temp_zone = 0; left_edge_iter(&temp_zone, rect);)
				{
					// If zone doesn't have a x_prev neighbor
					if(temp_zone->x_prev == 0)
					{
						if(verbose) print("\t\t-x failed. Reason: no neighbor.\n");
						left_can_expand = FALSE;
						break;
					}
					// If this zone's x_prev is not neighbors with the last zone's x_prev, then we can't expand
					if(last_neighbor != 0 && !zones_are_neighbors(temp_zone->x_prev, last_neighbor))
					{
						if(verbose) print("\t\t-x failed. Reason: Two consecutive x_prevs are not neighbors.\n");
						left_can_expand = FALSE;
						break;
					}
					// If this zone's x_prev has already been processed, then we can't expand to it
					if(is_zone_in_list(temp_zone->x_prev, &zones_processed))
					{
						if(verbose) print("\t\t-x failed. Reason: Neighbor zone has already been processed.\n");
						left_can_expand = FALSE;
						break;
					}
					last_neighbor = temp_zone->x_prev;					
				}
				// ----------------------------------------------------------------------
				// Check if we are expanding into another rectangle
				// ----------------------------------------------------------------------
				// if(left_can_expand)
				// {
				// 	if(intersects_with_rectangles((rect->min)->x_prev, rect->max, navgen_rectangles, rect))
				// 	{
				// 		left_can_expand = FALSE;
				// 	}
				// }
				// ----------------------------------------------------------------------
				// If we got to the edge and found them all, expand the rectangle
				// ----------------------------------------------------------------------
				if(left_can_expand)
				{
					// Sweep again, adding all the zones to the rect
					for(temp_zone = 0; left_edge_iter(&temp_zone, rect);)
					{
						remove_zone_from_list(temp_zone->x_prev, &zones_to_process);
						add_zone_to_list(temp_zone->x_prev, &zones_processed);
					}
					// Update bottom-left zone
					rect->min = (rect->min)->x_prev;
					if(verbose) print("\t\tExpanded rectangle at -x\n");
				}
			}
			// ---------------------------------------------------



			// If this rectangle can no longer expand in any direction, stop
			if(!top_can_expand && !right_can_expand && !bottom_can_expand && !left_can_expand)
			{
				break;
			}
		}

		// NOTE - Return to only create and expand one rectangle per frame
		return;
	}
}

int cl_navgen_phase_rectangle_expansion_finished()
{
	// return TRUE;
	// return FALSE;
	return zones_to_process == 0;
}
void cl_navgen_draw_phase_rectangle_expansion()
{
	vector color = [0.2,0.8,0.2];
	float alpha = 0.1;

	navgen_rectangle *rect = navgen_rectangles;

	while(rect != 0)
	{
		// Get 4 corners
		navgen_cell *tr = (rect->max)->tr_cell;
		navgen_cell *tl = (get_top_left_zone(rect))->tl_cell;
		navgen_cell *bl = (rect->min)->bl_cell;
		navgen_cell *br = (get_bottom_right_zone(rect))->br_cell;

		vector a = [bl->x, bl->y, bl->z];
		vector b = [br->x, br->y, br->z];
		vector c = [tr->x, tr->y, tr->z];
		vector d = [tl->x, tl->y, tl->z];

		cl_navmesh_draw_quad(a,b,c,d,color,alpha,TRUE);
		rect = rect->next;
	}
}
// ===========================================================================================================
// NAVGEN_PHASE_RECTANGLE_VECTORIZATION
// ===========================================================================================================
void cl_navgen_phase_rectangle_vectorization_start()
{
	// Delete all rectangle vertices
	navgen_rectangle *rect = navgen_rectangles;

	while(rect != 0)
	{
		navgen_cell *vert = rect->verts;
		navgen_cell *vert_next;

		while(vert != 0)
		{
			vert_next = vert->next;
			remove_cell_from_list(vert, &(rect->verts));
			delete_cell(vert);

			vert = vert_next;
		}

		rect = rect->next;
	}
}
void cl_navgen_phase_rectangle_vectorization_step()
{
	navgen_rectangle *rect1;
	navgen_rectangle *rect2;

	for(rect1 = navgen_rectangles; rect1 != 0; rect1 = rect1->next)
	{
		// Add the four corners of rect1 to rect1's list of verts
		navgen_cell *tr = (rect1->max)->tr_cell;
		navgen_cell *br = get_bottom_right_zone(rect1)->br_cell;
		navgen_cell *bl = (rect1->min)->bl_cell;
		navgen_cell *tl = get_top_left_zone(rect1)->tl_cell;

		// Create a cell vert for each of these corners
		navgen_cell *tr_vert = create_cell(tr->x, tr->y, tr->z);
		navgen_cell *br_vert = create_cell(br->x, br->y, br->z);
		navgen_cell *bl_vert = create_cell(bl->x, bl->y, bl->z);
		navgen_cell *tl_vert = create_cell(tl->x, tl->y, tl->z);

		// Add these four cell verts to rect1's list of verts
		add_cell_to_list(tr_vert, &(rect1->verts));
		add_cell_to_list(br_vert, &(rect1->verts));
		add_cell_to_list(bl_vert, &(rect1->verts));
		add_cell_to_list(tl_vert, &(rect1->verts));


		vector r1_min = get_cell_pos((rect1->min)->bl_cell);
		vector r1_max = get_cell_pos((rect1->max)->tr_cell);

		for(rect2 = navgen_rectangles; rect2 != 0; rect2 = rect2->next)
		{
			if(rect1 == rect2)
				continue;

			vector r2_min = get_cell_pos((rect2->min)->bl_cell);
			vector r2_max = get_cell_pos((rect2->max)->tr_cell);

			// Check if the rectangles are neighbors
			// Easy early-out test, Check if the mins / maxs of the rectangles are within 2 cells of each other
			// If they're not, then it's impossible for these rectangles to be neighbors

			if(r1_min.x > r2_max.x + 2 * navgen_cell_size)
				continue;
			if(r1_max.x < r2_min.x - 2 * navgen_cell_size)
				continue;
			if(r1_min.y > r2_max.y + 2 * navgen_cell_size)
				continue;
			if(r1_max.y < r2_min.y - 2 * navgen_cell_size)
				continue;


			// At this point... the rectangles are close enough that they _might_ be neighbors
			navgen_zone *r1_zone;
			navgen_zone *r2_zone;

			navgen_zone *first_neighbor_zone = 0;
			navgen_zone *last_neighbor_zone = 0;
			navgen_cell *first_neighbor_cell = 0;
			navgen_cell *last_neighbor_cell = 0;

			// ---------------------------------------------------------------------
			// Check rect1's top edge
			// ---------------------------------------------------------------------
			// Only check this if we don't have a shared edge
			// (NOTE: This is always true for the top edge check, but the rest of the edges have it, so keep it.)
			if(first_neighbor_zone == 0)
			{
				// Sweep rect1's top edge from top right to top left
				for(r1_zone = 0; top_edge_iter(&r1_zone, rect1);)
				{
					// Sweep rect2's bottom edge from bottom left to bottom right
					for(r2_zone = 0; bottom_edge_iter(&r2_zone, rect2);)
					{
						if(zones_are_neighbors(r1_zone, r2_zone))
						{
							first_neighbor_zone = first_neighbor_zone == 0 ? r1_zone : first_neighbor_zone;
							last_neighbor_zone = r1_zone;
							first_neighbor_cell = first_neighbor_cell == 0 ? r1_zone->tr_cell : first_neighbor_cell;
							last_neighbor_cell = r1_zone->tl_cell;
						}
					}
				}
			}

			// ---------------------------------------------------------------------
			// Check rect1's right edge
			// ---------------------------------------------------------------------
			// Only check this if we don't have a shared edge
			if(first_neighbor_zone == 0)
			{
				// Sweep rect1's right edge from top right to bottom right
				for(r1_zone = 0; right_edge_iter(&r1_zone, rect1);)
				{
					// Sweep rect2's left edge from bottom left to top left
					for(r2_zone = 0; left_edge_iter(&r2_zone, rect2);)
					{
						if(zones_are_neighbors(r1_zone, r2_zone))
						{
							first_neighbor_zone = first_neighbor_zone == 0 ? r1_zone : first_neighbor_zone;
							last_neighbor_zone = r1_zone;
							first_neighbor_cell = first_neighbor_cell == 0 ? r1_zone->tr_cell : first_neighbor_cell;
							last_neighbor_cell = r1_zone->br_cell;
						}
					}
				}
			}

			// ---------------------------------------------------------------------
			// Check rect1's bottom edge
			// ---------------------------------------------------------------------
			// Only check this if we don't have a shared edge
			if(first_neighbor_zone == 0)
			{
				// Sweep rect1's bottom edge from bottom left to bottom right
				for(r1_zone = 0; bottom_edge_iter(&r1_zone, rect1);)
				{
					// Sweep rect2's top edge from top right to top left
					for(r2_zone = 0; top_edge_iter(&r2_zone, rect2);)
					{
						if(zones_are_neighbors(r1_zone, r2_zone))
						{
							first_neighbor_zone = first_neighbor_zone == 0 ? r1_zone : first_neighbor_zone;
							last_neighbor_zone = r1_zone;
							first_neighbor_cell = first_neighbor_cell == 0 ? r1_zone->bl_cell : first_neighbor_cell;
							last_neighbor_cell = r1_zone->br_cell;
						}
					}
				}
			}

			// ---------------------------------------------------------------------
			// Check rect1's left edge
			// ---------------------------------------------------------------------
			// Only check this if we don't have a shared edge
			if(first_neighbor_zone == 0)
			{
				// Sweep rect1's left edge from bottom left to top left
				for(r1_zone = 0; left_edge_iter(&r1_zone, rect1);)
				{
					// Sweep rect2's right edge from top right to bottom right
					for(r2_zone = 0; right_edge_iter(&r2_zone, rect2);)
					{
						if(zones_are_neighbors(r1_zone, r2_zone))
						{
							first_neighbor_zone = first_neighbor_zone == 0 ? r1_zone : first_neighbor_zone;
							last_neighbor_zone = r1_zone;
							first_neighbor_cell = first_neighbor_cell == 0 ? r1_zone->bl_cell : first_neighbor_cell;
							last_neighbor_cell = r1_zone->tl_cell;
						}
					}
				}
			}

			// ---------------------------------------------------------------------

			if(first_neighbor_zone != 0)
			{
				// A single cell does not an edge make
				if(first_neighbor_cell != last_neighbor_cell)
				{
					navgen_cell *first_cell_vert;
					navgen_cell *last_cell_vert;

					// Create a cell vert for these two points
					first_cell_vert = create_cell(first_neighbor_cell->x, first_neighbor_cell->y, first_neighbor_cell->z);
					last_cell_vert = create_cell(last_neighbor_cell->x, last_neighbor_cell->y, last_neighbor_cell->z);
		
					// Add these two cell verts to rect1's list of verts
					// Only add them if the rectangle doesn't already have a matching vertex.
					if(matching_cell_in_list(first_cell_vert, &(rect1->verts)) == 0)
					{
						add_cell_to_list(first_cell_vert, &(rect1->verts));
					}
					if(matching_cell_in_list(last_cell_vert, &(rect1->verts)) == 0)
					{
						add_cell_to_list(last_cell_vert, &(rect1->verts));
					}
				}
			}
		}
	}
}
int cl_navgen_phase_rectangle_vectorization_finished()
{
	// rectangle vectorization finishes in a single function call, so just return TRUE here
	return TRUE;
}
void cl_navgen_draw_phase_rectangle_vectorization()
{
	vector rect_vert_color = [0,0,1];
	float rect_vert_alpha = 0.5;

	navgen_rectangle *rect = navgen_rectangles;

	while(rect != 0)
	{
		// Draw all of the rect's vertex cells
		navgen_cell *vert = rect->verts;

		while(vert != 0)
		{
			cl_navmesh_draw_vert([vert->x, vert->y, vert->z],rect_vert_color,rect_vert_alpha);
			vert = vert->next;
		}

		rect = rect->next;
	}
}
// ===========================================================================================================
// NAVGEN_PHASE_RECTANGLE_TRIANGULATION
// ===========================================================================================================
// ------------------------------------------------------------------------------------------------------
// navgen_rectangle struct and linked list logic
// ------------------------------------------------------------------------------------------------------
// Circular doubley-linked list for alorithm, with support for any data type.
struct cdll_node
{
	// Linked list nodes
	cdll_node *next;
	cdll_node *prev;

	// Any desired data may be stored here.
	void *data;
};

cdll_node *(void *data) create_cdll_node = 
{
	cdll_node *new_node = memalloc(sizeof(cdll_node));
	new_node->next = new_node;
	new_node->prev = new_node;
	new_node->data = data;
	return new_node;
}

void(cdll_node *node) delete_cdll_node = 
{
	// Maintain the doubley-linked list
	if(node->next != 0 && node->prev != 0)
	{
		node->prev = node->next;
	}
	memfree(node);
}

void(cdll_node *node, cdll_node **list_root) add_cdll_node_to_list = 
{
	if(*list_root != 0)
	{
		node->next = *list_root;
		node->prev = (*list_root)->prev;
		((*list_root)->prev)->next = node;
		(*list_root)->prev = node;
	}
	*list_root = node;
}

void(cdll_node *node, cdll_node **list_root) remove_cdll_node_from_list =
{
	if(node == *list_root)
	{
		// If there is more than one element in the list
		if(node->next != node)
		{
			*list_root = node->next;
		}
		// There is only one element in the list
		else
		{
			*list_root = 0;
		}
	}

	(node->prev)->next = node->next;
	(node->next)->prev = node->prev;
	node->next = node;
	node->prev = node;
}
// ------------------------------------------------------------------------------------------------------

void cl_navgen_phase_rectangle_triangulation_start()
{

}
void cl_navgen_phase_rectangle_triangulation_step()
{
	// TODO
}
int cl_navgen_phase_rectangle_triangulation_finished()
{
	// return FALSE;
	return TRUE;
}
void cl_navgen_draw_phase_rectangle_triangulation()
{
	vector color = [0.2,0.8,0.2];
	float alpha = 0.1;

	navgen_rectangle *rect = navgen_rectangles;

	while(rect != 0)
	{
		// FIXME - This "computes" triangles by just taking the first 3 verts, drawing as a tri, 
		// FIXME   then shifting each of the 3 verts to the next one, drawing a tri, etc.

		// FIXME - The vertices make up a concave polygon, however, there are vertices
		// FIXME   that form a 180 degree corner. The ear clipping triangulation algorithm 
		// FIXME   may produce 0-area triangles in this situation.


		// TODO - Use new "create_cdll_node" data struct to sort the vertices in CCW order:
		// TODO   Honestly, I may just want to allocate an array for each of the verts. Need to count the verts first.

		int num_verts = 0;
		navgen_cell *vert = rect->verts;
		while(vert != 0)
		{
			num_verts++;
			vert = vert->next;
		}

		
		// One entry per vert
		navgen_cell **verts = (navgen_cell **) memalloc(sizeof(navgen_cell*) * num_verts);
		float *vert_angles = (float *) memalloc(sizeof(float) * num_verts);

		// Populate the verts array
		vert = rect->verts;
		int i = 0;
		while(vert != 0)
		{
			verts[i] = vert;
			vert_angles[i] = 0;
			i++;
			vert = vert->next;
		}
		

		// This sorting ensures clockwise order



		//Calculating center of the polygon
		vector center = [0,0,0];
		for(i = 0; i < num_verts; i++)
		{
			vert = verts[i];
			center += [vert->x, vert->y, vert->z];
		}
		center /= (float)num_verts;
		print("Center of selected polygon: ",vtos(center),".\n\n");

		//Calculating vertex angles:
		for(i = 0; i < num_verts; i++)
		{
			//Calculating angle of vert
			vert_angles[i] = atan2((verts[i])->y - center.y,(verts[i])->x - center.x);
		}


		//Sorting from least to greatest
		for(i = 0; i < num_verts; i++)
		{
			//Finding lowest value from i to num_verts
			float lowest_value = vert_angles[i];
			float lowest_index = i;
			for(float j = i; j < num_verts; j++)
			{
				if(vert_angles[j] < lowest_value)
				{
					lowest_value = vert_angles[j];
					lowest_index = j;
				}
			}
			//Swapping the lowest value with index i
			float temp_angle = vert_angles[i];
			vert_angles[i] = vert_angles[lowest_index];
			vert_angles[lowest_index] = temp_angle;
			
			navgen_cell *temp_vert = verts[i];
			verts[i] = verts[lowest_index];
			verts[lowest_index] = temp_vert;
		}
		


		// TODO Use this:
		//=====================================================================
		/*
		if(selected_vert_count < 3)
		{
			print("Not enough selected vertices to make a polygon (need 3).\n");
			return;
		}
		
		if(cl_navmesh_poly_count >= cl_navmesh_polies.length)
		{
			print("Max polygon count reached.\n");
			return;
		}
		
		if(cl_navmesh_is_poly_selected())
		{
			print("This polygon already exists.\n");
			return;
		}
		
		
		//Sorting the verts so the polygon is build consecutively (i.e. vert 0 -> vert 1 is an edge, 1->2, 2->3, and 3->0 are all edges)
		//Furthermore, this sorting will ensure the verts are sorted in a clockwise order, so we also apply it to tris
		
		
		//Printing all polygon vertices
		print("Selected Verts: [");
		for(float j = 0; j < selected_vert_count; j++)
		{
			print("(",ftos(j),", ",ftos(selected_verts[j]),", ",vtos(cl_navmesh_verts[selected_verts[j]].pos),") , ");
		}
		print("]\n\n");
		
		//Calculating center of the polygon
		local vector center = [0,0,0];
		for(float j = 0; j < selected_vert_count; j++)
		{
			center += cl_navmesh_verts[selected_verts[j]].pos;
		}
		center /= selected_vert_count;
		
		print("Center of selected polygon: ",vtos(center),".\n\n");
		
		float vert_angle[NAV_MAX_SELECTED_VERTS];
		
		//For suppressing uninitialised vert_angle compiler warning
		vert_angle[0] = 0;
		
		//Calculating vertex angles:
		for(float j = 0; j < selected_vert_count; j++)
		{
			//Calculating angle of vert
			vert_angle[j] = atan2(cl_navmesh_verts[selected_verts[j]].pos.y - center.y,cl_navmesh_verts[selected_verts[j]].pos.x - center.x);
		}
		
		//Sorting from least to greatest
		for(float j = 0; j < selected_vert_count; j++)
		{
			//Finding lowest value from j to selected_vert_count
			float lowest_value = vert_angle[j];
			float lowest_index = j;
			for(float k = j; k < selected_vert_count; k++)
			{
				if(vert_angle[k] < lowest_value)
				{
					lowest_value = vert_angle[k];
					lowest_index = k;
				}
			}
			//Swapping the lowest value with index j
			float temp_angle = vert_angle[j];
			vert_angle[j] = vert_angle[lowest_index];
			vert_angle[lowest_index] = temp_angle;
			
			float temp_vert = selected_verts[j];
			selected_verts[j] = selected_verts[lowest_index];
			selected_verts[lowest_index] = temp_vert;
		}
		
		//Vert angles
		print("Sorted Verts: [");
		for(float j = 0; j < selected_vert_count; j++)
		{
			print("(",ftos(j),", ",ftos(selected_verts[j]),", ",vtos(cl_navmesh_verts[selected_verts[j]].pos),") ,");
		}
		print("]\n\n");
		
		print("Sorted Vert angles: [");
		for(float j = 0; j < selected_vert_count; j++)
		{
			print(", ",ftos(vert_angle[j]));
		}
		print("]\n\n");
		
		
		

		for(float i = 0; i < selected_vert_count; i++)
		{
			cl_navmesh_polies[cl_navmesh_poly_count].verts[i] = selected_verts[i];
		}
		cl_navmesh_polies[cl_navmesh_poly_count].vert_count = selected_vert_count;
		cl_navmesh_poly_count++;
		*/
		//=====================================================================


		memfree(vert_angles);
		memfree((void*)verts);



		// Proposed algorithm:
		// Sort points on a circular doubley-linked list in CCW or CW order (see navmesh_editor for sorting points)
		// Take first three points
		// while(pt1 != pt3)
		//     if the triangle made up of these points is not co-linear AND no other points in the list lie on the triangle
		// 		       (e.g. each triangle edge is not co-linear with ANY OTHER verts on the list)
		//         Make a triangle at these 3 points
		//         Pop point 2 from the list
		//         Take next three points starting at pt1 in the updated list
		//             (pt1 = pt1; pt2 = pt1->next; pt3 = pt2->next;)
		//     else
		//		    Advance to next three points
		//             (pt1 = pt1->next; pt2 = pt1->next; pt3 = pt2->next;)






		navgen_cell *v1 = rect->verts;
		navgen_cell *v2 = v1->next;
		navgen_cell *v3 = v2->next;

		while(TRUE) 
		{
			vector a = [v1->x, v1->y, v1->z];
			vector b = [v2->x, v2->y, v2->z];
			vector c = [v3->x, v3->y, v3->z];

			cl_navmesh_draw_tri(a,b,c,color,alpha,TRUE);

			v1 = v1->next;
			if(v1 == 0) break;
			v2 = v2->next;
			if(v2 == 0) break;
			v3 = v3->next;
			if(v3 == 0) break;
		}

		rect = rect->next;
	}
}
// ===========================================================================================================
// NAVGEN_PHASE_MESH_DETRIANGULATION
// ===========================================================================================================
void cl_navgen_phase_mesh_detriangulation_start()
{

}
void cl_navgen_phase_mesh_detriangulation_step()
{

}
int cl_navgen_phase_mesh_detriangulation_finished()
{
	return TRUE;
}
void cl_navgen_draw_phase_mesh_detriangulation()
{

}
